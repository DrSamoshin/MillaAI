# Новая архитектура Aimi

## 1. Общая структура
- **API слой (FastAPI)**
  - REST `POST /chat/send`, WebSocket `/ws/chat`.
  - Быстрый ответ: сразу сохраняет сообщение, дергает сервис диалога.
- **Сервис диалога**
  - Управляет цепочкой: кеш → оркестратор → LLM → сохранение ответов.
  - Не выполняет тяжелых задач — только онлайн логика.
- **Фоновый контур**
  - Асинхронные воркеры (Celery/APScheduler/async) выполняют тяжелые операции: свертка диалогов, планирование напоминаний, пересчет графа/векторов, отправка уведомлений.

## 2. Хранилище событий
- **Postgres** — основная БД.
  - `users` – базовые данные, timezone, настройки.
  - `goals` – цели: id, user_id, заголовок, описание, статус, срок.
  - `habits` – привычки/рутины, связанные с целями.
  - `chat_messages` – все сообщения (user/assistant) с `metadata` (теги, linked_task_id, настроение).
  - `events` – единая таблица для задач/событий (тип, статус, временные поля, ссылка на цель, источник).
  - `reminder_queue` – запланированные напоминания (event_id, trigger_at, статус, канал).
  - `reminder_logs` – история отправки.
  - `task_history`/`event_history` – изменения статусов (опционально JSONB).
- **Кеш слоя диалога** (Redis / in-memory): хранит текущую сессию, чтобы быстрый ответ не зависел от тяжелых запросов.
  - После завершения сессии → summary → запись в Postgres, кеш очищается.
- **`user_state`**: агрегированная свертка о пользователе (последний summary, активные цели, настроение, предпочтения). Обновляется воркерами при каждой свертке, чтобы новый диалог сразу видел «портрет» пользователя.

## 3. Векторная и графовая память
- **Графовая память**
  - Отдельное хранилище (Neo4j или Postgres + graph schema) с узлами: Goal, Habit, State, Context, Person.
  - Ребра: `habit -> goal`, `task -> goal`, `state -> goal`, `context -> state`, веса/метки.
  - Обновляется в фоне после аналитики диалога/summary.
- **Векторная память** (PGVector/OpenSearch)
  - Сохраняем embeddings summary, ключевых фактов, заметок.
  - Используется оркестратором для semantic retrieval «похожих случаев».

## 4. Pipeline обработки сообщения
### Пользовательский цикл
1. **Старт диалога**
   - API фиксирует user_id, создает/очищает кеш сессии.
   - Диалоговый сервис обращается к `user_state`, графу и векторной памяти, чтобы собрать стартовый контекст: активные цели, привычки, ближайшие события, последние summary.
   - Системный промпт включает найденные цели/планы («помни про цель X, событие Y сегодня в 18:00»).
2. **Каждое сообщение**
   - Сохраняем сообщение в кеш (до 30 реплик) и `chat_messages` (с `metadata`).
   - Оркестратор подмешивает свежий контекст (кеш N сообщений + резюме) и вызывает диалоговый LLM.
   - Ответ ассистента также записывается в кеш/БД.
   - По ходу диалога ассистент уточняет цели/задачи, создаёт записи в `goals`, `tasks`, `events` (со статусом `planned`/`pending_confirmation`).
3. **Завершение/таймаут сессии**
   - Триггеры: явное «пока», таймаут неактивности (10 минут), достижение лимита (30 сообщений), системный exit.
   - Воркер формирует summary (короткое повествование, список фактов, намерения).
   - Summary + факты → `chat_messages`/`task_history` + генерация embedding → запись в `memory_vectors`.
   - Обновляется `user_state` (последний summary, активные цели, настроение), старые записи вектора можно помечать `is_active=false`.
   - Незавершённые действия (pending) сохраняются, чтобы при следующем диалоге ассистент первым делом уточнил их статус.
   - Кеш очищается, но в памяти остаётся summary / ключевые задачи.

### Фоновая обработка
- **Summary & Embedding Worker**
  - Триггер: завершилась сессия/выполнена задача.
  - Действия: свертка диалога, извлечение фактов (например, «готовится к интервью в компании Z»), обновление `goals`/`events`, генерация embedding, запись в `memory_vectors`, обновление графа (узлы Goal/Context, ребра поддержек), отметка `is_active` для устаревших записей, обновление `user_state`.

- **Notification Scheduler**
  - Триггер: периодически (каждые N минут) или после изменений в `events`.
  - Действия: просматривает `events` со статусом `planned`, рассчитывает `reminder_queue` (например, T-24h, T-2h, T-15m), устанавливает `status=scheduled`.
  - Отдельный воркер отправляет уведомление (push/email/внутренний ассистент), фиксирует в `reminder_logs`, переводит событие в `awaiting_feedback`.

- **Classifier/Context Worker** (опционально)
  - Анализирует новые сообщения, чтобы проставить `metadata`: теги тем, настроение, `goal_id`. Может спрашивать пользователя для подтверждения.
  - Обновляет веса в графе (например, если цель упоминается чаще — увеличить важность).

- **Cleanup Worker**
  - Удаляет/архивирует старые кеш-записи, отмечает `memory_vectors.is_active=false` для устаревших embedding, пересчитывает статистику (успех целей, % напоминаний).

## 5. Модули
- **Модуль событий** (`EventRepository`): `save_message`, `list_recent_messages`, `list_events`, `create_event`.
- **Оркестратор** (`ConversationOrchestrator`): готовит контекст, связывает цели, решает, когда спросить пользователя.
- **LLM клиент** (`LLMClient`): обращается к выбранной модели, поддерживает варианты (OpenAI, локальный).
- **Notification scheduler**: фоновая задача для `reminder_queue` и отправки сообщений.
- **Summary/Embedding worker**: генерирует свертки, обновляет граф и векторный слой.

## 6. Следующие шаги
1. Спроектировать схему БД (таблицы, индексы, связи).
2. Определить структуру кеша (Redis/Bolt) для активной сессии.
3. Описать API сервисных методов (create_event, complete_task, postpone_event).
4. Реализовать простого оркестратора (без Graphiti): хранение контекста и ответов.
5. Подключить асинхронные воркеры и настроить очередь напоминаний.
